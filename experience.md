### 1. 函数中几种const构不构成重载的分析
- 函数中值传递不构成重载，因为传入的只是一个值，而且会报重定义错误

        void test(int a){
            cout << a << endl;
        }
        //下面的代码会报重定义错误
        void test(const int a){
            cout << a << endl; 
        }
- 函数中引用传递和指针传递增加const构成重载，因为传入的是确切的对象，`const`可以区分传入的这些对象能否被修改的性质

        int test(int *a){
            return *a;
        }
        int test(const int *a){
            return *a;
        }

- 成员函数中函数后面加`const`构成重载，和上面的情况同理，是能决定成员变量能否被修改的
  
        class test{
        public:
            test(){}
            ~test(){}
            int display(){
                return this.a;
            }
            int display const(){
                return this.a;
            }
        private:
            int a;
        }

### 2.如何做到在const成员函数内修改成员变量

- 使用mutable关键字去修饰成员变量，这样成员变量始终是可以变化的
- 定义一个常量指针指向this所指的对象，然后用这个指针去修改成员变量

        class test{
        public:
            test(){}
            ~test(){}

            void display(int a) const{
                test *const te = const_cast<test *const>(this);
                te->value = 2;
                cout << te-value << endl;
            }
        private:
            int value;
        }

### 3.内联函数和宏定义的区别
1.内联函数是函数，有参数类型检查，更为安全
2.内联函数由编译器进行处理，而宏定义由预处理器进行处理
3.内联函数处理时被插入到对应代码区域，而宏定义只是简单的文本替换

### 4.c++编译过程
分为预处理+编译+汇编+链接
  - 预处理：主要处理那些源代码中以#开始的预编译指令，主要处理规则如下：
    - 将宏定义进行文本替换
    - 将`#include`的文件插入到对应位置（递归进行，因为可能循环包含）
    - 删除注释
  - 编译：进行一系列词法分析，语法分析，语义分析及优化后生成相应的汇编代码文件（内联函数就在这一阶段）
  - 汇编：将汇编代码转变成机器语言
  - 链接：将各个目标文件组装在一起，并生成可执行文件。
  
  ### 5.程序的内存分配
  1.栈区：由编译器自动分配释放，存放函数的参数值，局部变量等。
  2.堆区：由程序员自己分配释放，分配方式类似于链表
  3.全局静态区：全局变量和静态变量的位置，初始化的在一起，未初始化的在一起
  4.常量区：常量存放地址，程序接受系统释放
  5.程序代码区：存放函数的二进制代码

  ### 6.内存中堆和栈的区别
  1.栈由系统统一分配，例如局部变量声明后就自动放在栈中（先进后出）
  2.堆需要自己申请，比如malloc函数和new

